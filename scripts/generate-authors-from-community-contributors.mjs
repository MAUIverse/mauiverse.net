import { promises as fs } from 'node:fs';
import path from 'node:path';
import { fileURLToPath } from 'node:url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const contributorsDir = path.resolve(__dirname, '../src/content/community-contributors');
const outputPath = path.resolve(__dirname, '../src/data/authors.generated.ts');
const snippetsOutputPath = path.resolve(__dirname, '../.vscode/author-frontmatter.code-snippets');

function parseYamlValue(rawValue) {
  const value = rawValue.trim();

  if (value === 'true') return true;
  if (value === 'false') return false;

  if (value.startsWith('"') && value.endsWith('"')) {
    return value.slice(1, -1).replace(/\\"/g, '"').replace(/\\\\/g, '\\');
  }

  if (value.startsWith("'") && value.endsWith("'")) {
    return value.slice(1, -1).replace(/\\'/g, "'").replace(/\\\\/g, '\\');
  }

  return value;
}

function parseSimpleYaml(content) {
  const record = {};
  const lines = content.split(/\r?\n/);

  for (const line of lines) {
    const trimmed = line.trim();
    if (trimmed === '' || trimmed.startsWith('#')) continue;

    const match = line.match(/^([A-Za-z0-9_]+):\s*(.*)$/);
    if (!match) continue;

    const [, key, rawValue] = match;
    record[key] = parseYamlValue(rawValue);
  }

  return record;
}

function assertRequired(entry, fieldName, filename) {
  if (!(fieldName in entry) || typeof entry[fieldName] !== 'string' || entry[fieldName].trim() === '') {
    throw new Error(`Missing required field \"${fieldName}\" in ${filename}`);
  }
}

function toEntryLiteral(entry) {
  const lines = [
    `    key: ${JSON.stringify(entry.key)},`,
    `    displayName: ${JSON.stringify(entry.displayName)},`,
  ];

  if (entry.imagePath != null) {
    lines.push(`    imagePath: ${JSON.stringify(entry.imagePath)},`);
  }

  if (entry.disableGitHubProfileLink != null) {
    lines.push(`    disableGitHubProfileLink: ${entry.disableGitHubProfileLink},`);
  }

  return `  {\n${lines.join('\n')}\n  }`;
}

function normalizeLookupText(value) {
  return value
    .normalize('NFD')
    .replace(/[\u0300-\u036f]/g, '')
    .toLowerCase();
}

function buildAuthorSnippetPrefixes(entry) {
  const normalizedDisplayName = normalizeLookupText(entry.displayName);
  const nameTokens = normalizedDisplayName.match(/[a-z0-9]+/g) ?? [];
  const firstName = nameTokens[0];
  const compactDisplayName = nameTokens.join('');

  const prefixes = [
    entry.key,
    entry.key.toLowerCase(),
    firstName,
    compactDisplayName,
  ].filter((prefix) => typeof prefix === 'string' && prefix.length > 0);

  return [...new Set(prefixes)];
}

function buildAuthorSnippets(authorEntries) {
  const snippets = {};

  for (const entry of authorEntries) {
    const snippetName = `Author: ${entry.displayName} (${entry.key})`;

    snippets[snippetName] = {
      scope: 'markdown',
      prefix: buildAuthorSnippetPrefixes(entry),
      body: entry.key,
      description: `Insert author handle '${entry.key}' for ${entry.displayName}`,
    };
  }

  return snippets;
}

async function main() {
  const files = (await fs.readdir(contributorsDir))
    .filter((name) => name.endsWith('.yaml') || name.endsWith('.yml'))
    .sort((left, right) => left.localeCompare(right));

  const parsedEntries = [];

  for (const fileName of files) {
    const fullPath = path.join(contributorsDir, fileName);
    const content = await fs.readFile(fullPath, 'utf8');
    const data = parseSimpleYaml(content);

    assertRequired(data, 'gitHubUsername', fileName);
    assertRequired(data, 'displayName', fileName);

    if (
      'disableGitHubProfileLink' in data &&
      typeof data.disableGitHubProfileLink !== 'boolean'
    ) {
      throw new Error(
        `Field \"disableGitHubProfileLink\" must be a boolean in ${fileName}`
      );
    }

    if ('avatarImagePath' in data && typeof data.avatarImagePath !== 'string') {
      throw new Error(`Field \"avatarImagePath\" must be a string in ${fileName}`);
    }

    const imagePath = typeof data.avatarImagePath === 'string' && data.avatarImagePath !== ''
      ? data.avatarImagePath
      : undefined;

    parsedEntries.push({
      key: data.gitHubUsername,
      displayName: data.displayName,
      imagePath,
      disableGitHubProfileLink:
        typeof data.disableGitHubProfileLink === 'boolean'
          ? data.disableGitHubProfileLink
          : undefined,
    });
  }

  const authorEntries = parsedEntries.sort((left, right) =>
    left.key.localeCompare(right.key, undefined, { sensitivity: 'base' })
  );

  const fileContents = `// This file is generated by scripts/generate-authors-from-community-contributors.mjs.\n// Do not edit manually.\n\nexport const authorEntries = [\n${authorEntries
    .map((entry) => toEntryLiteral(entry))
    .join(',\n')}\n] as const;\n`;

  const snippets = buildAuthorSnippets(authorEntries);
  const snippetsContents = `${JSON.stringify(snippets, null, 2)}\n`;

  await fs.writeFile(outputPath, fileContents, 'utf8');
  await fs.mkdir(path.dirname(snippetsOutputPath), { recursive: true });
  await fs.writeFile(snippetsOutputPath, snippetsContents, 'utf8');

  console.log(`Generated ${outputPath} with ${authorEntries.length} author entries.`);
  console.log(`Generated ${snippetsOutputPath} with ${authorEntries.length} author snippets.`);
}

await main();
