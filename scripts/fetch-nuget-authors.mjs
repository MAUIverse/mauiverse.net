import { access, mkdir, readdir, readFile, writeFile } from 'node:fs/promises';
import { constants } from 'node:fs';
import { dirname, extname, resolve } from 'node:path';

const CONTRIBUTORS_DIR = resolve(process.cwd(), 'src/content/community-contributors');
const OUTPUT_PATH = resolve(process.cwd(), 'src/data/nuget-authors.generated.ts');
const NUGET_QUERY_BASE = 'https://azuresearch-usnc.nuget.org/query';
const strictMode = /^(1|true|yes)$/i.test(process.env.NUGET_AUTHOR_SYNC_STRICT ?? '');
const forceRefresh = /^(1|true|yes)$/i.test(process.env.NUGET_AUTHOR_SYNC_FORCE_REFRESH ?? '');
const REQUEST_CONCURRENCY = 8;

async function hasExistingDataset() {
  try {
    await access(OUTPUT_PATH, constants.F_OK);
    return true;
  } catch {
    return false;
  }
}

function toArrayLiteral(values) {
  if (values.length === 0) {
    return '[]';
  }

  return `[
${values.map((value) => `  ${JSON.stringify(value)}`).join(',\n')}
]`;
}

function buildOutput(usernames) {
  const fetchedAt = new Date().toISOString();
  const source = `${NUGET_QUERY_BASE}?q=owner:<github-username>&prerelease=false&take=1`;
  const valuesLiteral = toArrayLiteral(usernames);

  return `// This file is generated by scripts/fetch-nuget-authors.mjs.\n// Do not edit manually.\n\nexport const nugetAuthorSource = ${JSON.stringify(source)};\nexport const nugetAuthorFetchedAt = ${JSON.stringify(fetchedAt)};\nexport const nugetAuthorUsernames = ${valuesLiteral} as const;\n`;
}

function extractGitHubUsername(content, fileName) {
  const match = content.match(/^gitHubUsername:\s*(?:"([^"]*)"|'([^']*)'|([^\n#]+))\s*$/m);
  const username = (match?.[1] ?? match?.[2] ?? match?.[3] ?? '').trim();
  if (username.length === 0) {
    throw new Error(`Missing gitHubUsername in ${fileName}.`);
  }

  return username;
}

async function readContributorUsernames() {
  const entries = await readdir(CONTRIBUTORS_DIR, { withFileTypes: true });
  const usernames = new Set();

  for (const entry of entries) {
    if (!entry.isFile()) {
      continue;
    }

    const extension = extname(entry.name).toLowerCase();
    if (extension !== '.yaml' && extension !== '.yml') {
      continue;
    }

    const filePath = resolve(CONTRIBUTORS_DIR, entry.name);
    const content = await readFile(filePath, 'utf8');
    const githubUsername = extractGitHubUsername(content, entry.name);
    usernames.add(githubUsername.toLowerCase());
  }

  return Array.from(usernames).sort((left, right) => left.localeCompare(right));
}

async function isNugetAuthor(username) {
  const url = `${NUGET_QUERY_BASE}?q=${encodeURIComponent(`owner:${username}`)}&prerelease=false&take=1`;
  const response = await fetch(url, {
    headers: {
      Accept: 'application/json',
      'User-Agent': 'mauiverse.net nuget author sync',
    },
  });

  if (!response.ok) {
    throw new Error(`Failed to query NuGet for ${username}: ${response.status} ${response.statusText}`);
  }

  const data = await response.json();
  return Number(data?.totalHits ?? 0) > 0;
}

async function mapWithConcurrency(values, concurrency, worker) {
  const results = new Array(values.length);
  let index = 0;

  async function runWorker() {
    while (index < values.length) {
      const currentIndex = index;
      index += 1;
      results[currentIndex] = await worker(values[currentIndex], currentIndex);
    }
  }

  await Promise.all(Array.from({ length: Math.min(concurrency, values.length) }, runWorker));
  return results;
}

async function fetchNugetAuthorUsernames(githubUsernames) {
  const flags = await mapWithConcurrency(githubUsernames, REQUEST_CONCURRENCY, (username) =>
    isNugetAuthor(username)
  );

  return githubUsernames.filter((_, index) => flags[index]);
}

async function writeDataset(usernames) {
  await mkdir(dirname(OUTPUT_PATH), { recursive: true });
  await writeFile(OUTPUT_PATH, buildOutput(usernames), 'utf8');
  console.log(`Wrote ${OUTPUT_PATH} (${usernames.length} usernames)`);
}

async function run() {
  try {
    const githubUsernames = await readContributorUsernames();
    if (githubUsernames.length === 0) {
      throw new Error('NuGet author sync found zero contributor usernames.');
    }

    const nugetAuthorUsernames = await fetchNugetAuthorUsernames(githubUsernames);
    await writeDataset(nugetAuthorUsernames);
  } catch (error) {
    const existingDataset = await hasExistingDataset();
    if (existingDataset && !strictMode && !forceRefresh) {
      const reason = error instanceof Error ? error.message : String(error);
      console.warn(`NuGet author sync failed; using existing dataset at ${OUTPUT_PATH}.`);
      console.warn(`Reason: ${reason}`);
      return;
    }

    throw error;
  }
}

run().catch((error) => {
  console.error(error instanceof Error ? error.message : String(error));
  process.exit(1);
});
